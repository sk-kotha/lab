Angular 17 and above

ng new hrms --defaults --standalone --routing                                                                        

* No “environments” folder: Environment files are used to store application configuration data like API URLs or third-party API configurations that might differ from environment to environment. Starting from Angular v15, environment files are not generated by default and can be added via a separate command. We will talk more about environments and builds/deployments in chapter 9
* No explicit “polyfills.ts” file: Polyfills are used to support older browsers like IE11 or prior. Previously, an Angular project had this file by default from the very beginning of the project, but now it is no longer autogenerated. This can also be added manually if necessary to support older browsers
* If we open the angular.json file, we will notice it is far shorter than we used to have in older projects

we can see another 3 differences from what we are used to:
* No app.module.ts file: The application is fully standalone and does not utilize modules for its architecture
* app.routes.ts file instead of app.routing.module.ts: this is again because we chose standalone
* app.config.ts file: this file will contain global configurations for our app, like providers, routing initialization, and more

import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterOutlet } from '@angular/router';
 
@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule, RouterOutlet],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'hrms';
}

* standalone: true marks this component as standalone and not belonging to any NgModule
* The imports array is used to import its dependencies (like other modules and standalone components/directives/pipes), as this component is standalone and does not rely on an NgModule to locate its dependencies, and instead imports them directly. Note that in v16 it imports CommonModule, to be able to use built-in directives and pipes, but those things are now also standalone and can be imported directly, i.e. we can write NgIf in the imports array and import only itself instead of bringing the entire CommonModule. In v17+, CommonModule is not imported by default at all.

import { Routes } from '@angular/router';
export const routes: Routes = [];

We can see that it is also simpler, as it does not use the RouterModule to register routes. Instead, those routes are only defined here and registered in the app.config.ts file

import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
 
import { routes } from './app.routes';
 
export const appConfig: ApplicationConfig = {
  providers: [provideRouter(routes)]
};

Again, two important things to note here:
* The ApplicationConfig interface has one property, providers, which is used to provide dependency injection tokens, as we did in NgModule-s previously with the property that shared the same name
* Routes are registered with a special new function called provideRouter, which also accepts an array of our route definitions, instead of RouterModule.forRoot(routes)
Now it seems we have reviewed all of our files, because, as mentioned previously, we do not have an “app.module.ts” file in a standalone setup. So if we do not have that file, how is our application being initialized and bootstrapped? Well, this logic fully moved to the main.ts file:

import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';
 
bootstrapApplication(AppComponent, appConfig)
  .catch((err) => console.error(err));

As we can see, main.ts now uses a special bootstrapApplication function, instead of the previous platformBrowserDynamic().bootstrapModule(AppModule), and directly bootstraps the AppComponent instead of an AppModule. In modern Angular apps, we do not need an NgModule, and this new function can directly create our application using one root component and the application configuration.

Starting from v17, a new template syntax is available that is projected to replace ngIf, ngSwitch, ngFor directives. This allows for better readable templates and compiler optimizations. In v18, this syntax is already stable. We will talk about these new commands in chapter 10.
